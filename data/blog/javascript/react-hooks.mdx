---
title: ğŸš€ Mastering React Hooks - useState, useEffect, useContext, useReducer & Custom Hooks ğŸ¯
date: '2025-01-04'
tags:
  [
    'ReactJS',
    'React Hooks',
    'useState',
    'useEffect',
    'useContext',
    'useReducer',
    'React Custom Hooks',
  ]
draft: false
summary: React Hooks are game-changers! ğŸ® They allow you to manage state and side effects in functional components without needing class components. In this guide, we'll dive deep into some of the most essential hooks - useState, useEffect, useContext, useReducer and how to create your own custom hooks! ğŸ”¥
---

React Hooks are game-changers! ğŸ® They allow you to manage state and side effects in functional components without needing class components.
In this guide, we'll dive deep into some of the most essential hooks: useState, useEffect, useContext, useReducer and how to create your own custom hooks! ğŸ”¥

---

## ğŸŸ¢ useState â€“ Managing State Like a Pro ğŸ˜

The useState hook helps you add state to functional components.
It returns a state variable and a function to update it.

### Example:

```JavaScript
import { useState } from 'react';

function Counter() {

const [count, setCount] = useState(0);

return (
    <div>
    <p>Count: {count}</p>
    <button onClick={() => setCount(count + 1)}>+</button>
</div>);

}
```

ğŸ‘‰ Key takeaway: Always update state using the setter function, never modify the state directly!

---

## ğŸ”µ useEffect â€“ Handling Side Effects ğŸ’¡

The useEffect hook is used for side effects like data fetching, subscriptions, and manually manipulating the DOM.

### Example:

```JavaScript
import { useState, useEffect } from 'react';

function Timer(){
    const [seconds, setSeconds] = useState(0);

    useEffect(() => {
        const intervalId = setInterval(() => setSeconds(s => s+1), 1000);
        return () => clearInterval(intervalId); // Cleanup function
    }, []); // Run only once, when component mounts;

    return <p>â³ Timer: {seconds} seconds</p>;
}
```

ğŸ” Pro Tip: Always clean up effects to avoid memory leaks! ğŸ§¹

---

## ğŸ”´ useContext â€“ Sharing State Across Components ğŸ”—

The useContext hook is used to share state between components without passing props down (prop drooling) manually.

### Example:

```JavaScript
import { createContext, useContext, useState } from 'react';

const ThemeContext = createContext('light');

function ThemedComponent() {
    const theme = useContext(ThemeContext);
    return <p style={{ color: theme === 'dark' ? 'white' : 'black'}}>Current Theme: {theme}</p>;
}
```

âœ¨ Best Practice: Combine useContext with useReducer for advanced state management! ğŸ’ª

---

## ğŸ”µ useReducer â€“ Managing Complex State ğŸ¤¯

The useReducer hook is an alternative to useState for managing complex state logic.

### Example:

```JavaScript
import { useReducer } from 'react';

const initialState = {count : 0};

function reducer(state, action){
    switch (action.type) {
        case 'increment':
            return {count: state.count + 1};
        case 'decrement':
            return {count: state.count - 1};
        default:
            return state;
    }
}

function Counter() {
    const [state, dispatch] = useReducer(reducer, initialState);

    return (
        <div>
            <p>Count: {state.count}</p>
            <button onClick={() => dispatch({type: 'increment'})}>+</button>
            <button onClick={() => dispatch({type: 'decrement'})}>-</button>
        </div>
        );
}
```

ğŸ’¡ Why use useReducer?

âœ… Great for managing complex state logic ğŸ”„ \
âœ… Works well with useContext for global state management ğŸŒ \
âœ… Keeps state updates predictable and structured ğŸ¯ \

---

## ğŸŸ  Custom Hooks â€“ Reusability at Its Best ğŸ”¥

Custom hooks allow you to extract reusable logic from components.

### Example:

```JavaScript
import { useState, useEffect } from 'react';

function useFetch(url){
    const [data, setData] = useState(null);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        fetch(url)
        .then(response => response.json())
        .then(data => {
            setData(data);
            setLoading(false);
            })
            .catch(error => console.error('Error:', error));
            }, [url]); // re-run effect if url changes

    return [data, loading];
    }
```

ğŸ’¡ Why use Custom Hooks?

âœ… Clean, reusable code âœ¨ \
âœ… Extract logic from components ğŸ—ï¸ \
âœ… Improve readability and maintainability ğŸ“– \

---

ğŸ¯ Wrapping Up

React Hooks make functional components more powerful and flexible!
ğŸ”¥ Whether you're managing state with useState, handling side effects with useEffect, using useContext for global state, useReducer for complex state logic, or creating custom hooks for reusability, mastering these hooks will level up your React skills. ğŸš€
Happy Coding! ğŸ’»âœ¨
